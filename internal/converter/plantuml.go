package converter

import (
	"bytes"
	"compress/flate"
	"compress/zlib"
	"context"
	"encoding/base64"
	"io"
	"strings"

	adfconv "github.com/rgonek/jira-adf-converter/converter"
)

// PlantUMLHandler implements adfconv.ExtensionHandler for the "plantumlcloud" extension.
type PlantUMLHandler struct{}

// ToMarkdown converts the ADF extension into a Pandoc fenced div wrapping a puml code block.
func (h *PlantUMLHandler) ToMarkdown(ctx context.Context, in adfconv.ExtensionRenderInput) (adfconv.ExtensionRenderOutput, error) {
	if in.Node.Type != "extension" && in.Node.Type != "bodiedExtension" {
		return adfconv.ExtensionRenderOutput{Handled: false}, nil
	}

	extensionKey := in.Node.GetStringAttr("extensionKey", "")
	if extensionKey != "plantumlcloud" {
		return adfconv.ExtensionRenderOutput{Handled: false}, nil
	}

	attrs := in.Node.Attrs

	// Extract parameters
	var filename, data string
	if params, ok := attrs["parameters"].(map[string]interface{}); ok {
		if macroParams, ok := params["macroParams"].(map[string]interface{}); ok {
			if fn, ok := macroParams["filename"].(map[string]interface{}); ok {
				if val, ok := fn["value"].(string); ok {
					filename = val
				}
			}
			if d, ok := macroParams["data"].(map[string]interface{}); ok {
				if val, ok := d["value"].(string); ok {
					data = val
				}
			}
		} else {
			// Fallback logic if macroParams is not structured that way
			if fn, ok := params["filename"].(string); ok {
				filename = fn
			} else if fn, ok := params["filename"].(map[string]interface{}); ok {
				if val, ok := fn["value"].(string); ok {
					filename = val
				}
			}
			if d, ok := params["data"].(string); ok {
				data = d
			} else if d, ok := params["data"].(map[string]interface{}); ok {
				if val, ok := d["value"].(string); ok {
					data = val
				}
			}
		}
	}

	if data == "" {
		return adfconv.ExtensionRenderOutput{Handled: false}, nil
	}

	decoded, err := h.decodeData(data)
	if err != nil {
		// Just output as unhandled if decoding fails
		return adfconv.ExtensionRenderOutput{Handled: false}, nil
	}

	if filename == "" {
		filename = "diagram.puml" // fallback
	}

	// Output inside the pandoc block generated by the framework
	markdown := "```puml\n" + strings.TrimSpace(decoded) + "\n```\n"

	return adfconv.ExtensionRenderOutput{
		Markdown: markdown,
		Metadata: map[string]string{
			"filename": filename,
		},
		Handled: true,
	}, nil
}

// decodeData decodes standard Base64 and decompresses via Zlib or Flate.
func (h *PlantUMLHandler) decodeData(data string) (string, error) {
	b, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return "", err
	}

	// Try Zlib first (usually what pako.deflate does)
	zReader, err := zlib.NewReader(bytes.NewReader(b))
	if err == nil {
		defer zReader.Close()
		decompressed, err := io.ReadAll(zReader)
		if err == nil {
			return string(decompressed), nil
		}
	}

	// Fallback to raw Deflate (pako.deflateRaw)
	fReader := flate.NewReader(bytes.NewReader(b))
	defer fReader.Close()
	decompressed, err := io.ReadAll(fReader)
	if err != nil {
		return "", err
	}

	return string(decompressed), nil
}

// encodeData compresses via raw Flate and encodes to standard Base64.
func (h *PlantUMLHandler) encodeData(data string) (string, error) {
	var buf bytes.Buffer
	writer, err := flate.NewWriter(&buf, flate.BestCompression)
	if err != nil {
		return "", err
	}
	_, err = writer.Write([]byte(data))
	if err != nil {
		return "", err
	}
	err = writer.Close()
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(buf.Bytes()), nil
}

// FromMarkdown parses the Pandoc fenced div/metadata and reconstructs the ADF extension.
func (h *PlantUMLHandler) FromMarkdown(ctx context.Context, in adfconv.ExtensionParseInput) (adfconv.ExtensionParseOutput, error) {
	if in.ExtensionKey != "plantumlcloud" {
		return adfconv.ExtensionParseOutput{Handled: false}, nil
	}

	// Extract the puml block content
	body := strings.TrimSpace(in.Body)
	if strings.HasPrefix(body, "```puml") {
		body = strings.TrimPrefix(body, "```puml")
	} else if strings.HasPrefix(body, "```plantuml") {
		body = strings.TrimPrefix(body, "```plantuml")
	} else if strings.HasPrefix(body, "```") {
		body = strings.TrimPrefix(body, "```")
	}
	if strings.HasSuffix(body, "```") {
		body = strings.TrimSuffix(body, "```")
	}
	pumlSrc := strings.TrimSpace(body)

	encoded, err := h.encodeData(pumlSrc)
	if err != nil {
		return adfconv.ExtensionParseOutput{Handled: false}, err
	}

	filename := in.Metadata["filename"]
	if filename == "" {
		filename = "diagram.puml"
	}

	node := adfconv.Node{
		Type: "extension", // or bodiedExtension? "extension" is safe usually.
		// Actually Confluence often uses bodiedExtension for macros with body,
		// but plantumlcloud might be just "extension" since data is in parameters.
		Attrs: map[string]interface{}{
			"extensionType": "com.atlassian.confluence.macro.core",
			"extensionKey":  "plantumlcloud",
			"parameters": map[string]interface{}{
				"macroParams": map[string]interface{}{
					"filename":   map[string]interface{}{"value": filename},
					"data":       map[string]interface{}{"value": encoded},
					"compressed": map[string]interface{}{"value": "true"},
					// revision is not strictly required for new updates, but we can set it to 1
					"revision": map[string]interface{}{"value": "1"},
				},
				"macroMetadata": map[string]interface{}{
					"macroId": map[string]interface{}{"value": "0"}, // just a dummy id, confluence ignores/overwrites
				},
			},
		},
	}

	return adfconv.ExtensionParseOutput{
		Node:    node,
		Handled: true,
	}, nil
}
